// Package handler implements HTTP request handlers for the HumanMark API.
//
// The main endpoint is POST /verify which accepts content and returns
// whether it was created by a human or generated by AI.
//
// Input formats:
//   - JSON body with "url" field: {"url": "https://example.com/image.jpg"}
//   - JSON body with "text" field: {"text": "content to verify"}
//   - Multipart form with "file" field: file upload
//
// Output format:
//
//	{
//	  "id": "unique-job-id",
//	  "human": true,
//	  "confidence": 0.94,
//	  "content_type": "text",
//	  "created_at": "2025-01-01T00:00:00Z"
//	}
package handler

import (
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/humanmark/humanmark/internal/repository"
	"github.com/humanmark/humanmark/internal/service"
	"github.com/humanmark/humanmark/pkg/logger"
)

// Handler holds dependencies for HTTP handlers.
// Using a struct allows for easy dependency injection and testing.
type Handler struct {
	detector      service.Detector
	repository    repository.Repository
	logger        *logger.Logger
	maxUploadSize int64
}

// Config holds configuration for creating a Handler.
type Config struct {
	Detector      service.Detector
	Repository    repository.Repository
	Logger        *logger.Logger
	MaxUploadSize int64
}

// New creates a new Handler with the given configuration.
func New(cfg Config) *Handler {
	return &Handler{
		detector:      cfg.Detector,
		repository:    cfg.Repository,
		logger:        cfg.Logger,
		maxUploadSize: cfg.MaxUploadSize,
	}
}

// VerifyRequest represents the JSON request body for /verify endpoint.
type VerifyRequest struct {
	// URL of content to verify (image, video, audio, or webpage)
	URL string `json:"url,omitempty"`

	// Text content to verify directly
	Text string `json:"text,omitempty"`
}

// VerifyResponse represents the JSON response from /verify endpoint.
type VerifyResponse struct {
	// ID is the unique identifier for this verification job
	ID string `json:"id"`

	// Human is true if the content was created by a human
	Human bool `json:"human"`

	// Confidence is how confident we are in the verdict (0.0-1.0)
	// Higher means more confident
	Confidence float64 `json:"confidence"`

	// ContentType is the detected type: text, image, audio, video
	ContentType string `json:"content_type"`

	// CreatedAt is when the verification was performed
	CreatedAt time.Time `json:"created_at"`

	// Details contains additional information about the detection
	// Only included if the request asked for detailed response
	Details *VerifyDetails `json:"details,omitempty"`
}

// VerifyDetails contains detailed detection information.
type VerifyDetails struct {
	// Detectors lists which detection methods were used
	Detectors []string `json:"detectors"`

	// AIScore is the raw AI probability score (0.0-1.0)
	// 0.0 = definitely human, 1.0 = definitely AI
	AIScore float64 `json:"ai_score"`

	// Signals contains individual detector results
	Signals []DetectorSignal `json:"signals,omitempty"`
}

// DetectorSignal represents a single detector's output.
type DetectorSignal struct {
	Name       string  `json:"name"`
	AIScore    float64 `json:"ai_score"`
	Confidence float64 `json:"confidence"`
}

// ErrorResponse represents an error response.
type ErrorResponse struct {
	Error   string `json:"error"`
	Code    string `json:"code,omitempty"`
	Details string `json:"details,omitempty"`
}

// Verify handles POST /verify requests.
// This is the main endpoint of the HumanMark API.
//
// It accepts three types of input:
//  1. JSON with "url": fetches and analyzes content from URL
//  2. JSON with "text": analyzes the provided text directly
//  3. Multipart form with "file": analyzes uploaded file
//
// Query parameters:
//   - detailed=true: include detailed detection information
func (h *Handler) Verify(w http.ResponseWriter, r *http.Request) {
	// Set JSON content type for response
	w.Header().Set("Content-Type", "application/json")

	// Determine input type based on Content-Type header
	contentType := r.Header.Get("Content-Type")

	var input service.DetectionInput
	var err error

	switch {
	case strings.HasPrefix(contentType, "multipart/form-data"):
		input, err = h.parseMultipartInput(r)
	case strings.HasPrefix(contentType, "application/json"):
		input, err = h.parseJSONInput(r)
	default:
		// Try to parse as JSON by default
		input, err = h.parseJSONInput(r)
	}

	if err != nil {
		h.writeError(w, http.StatusBadRequest, "invalid_input", err.Error())
		return
	}

	// Validate input
	if err := h.validateInput(input); err != nil {
		h.writeError(w, http.StatusBadRequest, "validation_error", err.Error())
		return
	}

	// Get request context for logging
	ctx := r.Context()
	log := h.logger.WithContext(ctx)

	log.Debug("processing verification request",
		"content_type", input.ContentType,
		"has_url", input.URL != "",
		"has_text", len(input.Text) > 0,
		"has_data", len(input.Data) > 0,
	)

	// Perform detection
	result, err := h.detector.Detect(ctx, input)
	if err != nil {
		log.Error("detection failed", "error", err)
		h.writeError(w, http.StatusInternalServerError, "detection_failed", "Failed to analyze content")
		return
	}

	// Store result
	job, err := h.repository.CreateJob(ctx, repository.Job{
		ContentType: string(result.ContentType),
		Human:       result.Human,
		Confidence:  result.Confidence,
		AIScore:     result.AIScore,
		Detectors:   result.Detectors,
		ContentHash: result.ContentHash,
	})
	if err != nil {
		log.Error("failed to store result", "error", err)
		// Continue - we can still return the result even if storage fails
	}

	// Build response
	response := VerifyResponse{
		ID:          job.ID,
		Human:       result.Human,
		Confidence:  result.Confidence,
		ContentType: string(result.ContentType),
		CreatedAt:   job.CreatedAt,
	}

	// Include details if requested
	if r.URL.Query().Get("detailed") == "true" {
		response.Details = &VerifyDetails{
			Detectors: result.Detectors,
			AIScore:   result.AIScore,
		}
	}

	// Write response
	h.writeJSON(w, http.StatusOK, response)
}

// parseJSONInput parses JSON request body into DetectionInput.
func (h *Handler) parseJSONInput(r *http.Request) (service.DetectionInput, error) {
	var req VerifyRequest
	
	// Limit body size for JSON requests
	body := http.MaxBytesReader(nil, r.Body, 10*1024*1024) // 10MB max for JSON
	defer body.Close()

	if err := json.NewDecoder(body).Decode(&req); err != nil {
		if err == io.EOF {
			return service.DetectionInput{}, errors.New("empty request body")
		}
		return service.DetectionInput{}, errors.New("invalid JSON: " + err.Error())
	}

	input := service.DetectionInput{}

	if req.URL != "" {
		input.URL = req.URL
		input.ContentType = service.ContentTypeFromURL(req.URL)
	} else if req.Text != "" {
		input.Text = req.Text
		input.ContentType = service.ContentTypeText
	} else {
		return service.DetectionInput{}, errors.New("request must include 'url' or 'text' field")
	}

	return input, nil
}

// parseMultipartInput parses multipart form upload into DetectionInput.
func (h *Handler) parseMultipartInput(r *http.Request) (service.DetectionInput, error) {
	// Limit upload size
	r.Body = http.MaxBytesReader(nil, r.Body, h.maxUploadSize)

	// Parse multipart form
	if err := r.ParseMultipartForm(h.maxUploadSize); err != nil {
		return service.DetectionInput{}, errors.New("failed to parse upload: " + err.Error())
	}

	// Get uploaded file
	file, header, err := r.FormFile("file")
	if err != nil {
		return service.DetectionInput{}, errors.New("no file uploaded: use 'file' form field")
	}
	defer file.Close()

	// Read file content
	data, err := io.ReadAll(file)
	if err != nil {
		return service.DetectionInput{}, errors.New("failed to read uploaded file")
	}

	// Detect content type from file
	contentType := service.ContentTypeFromMIME(header.Header.Get("Content-Type"))
	if contentType == service.ContentTypeUnknown {
		contentType = service.ContentTypeFromFilename(header.Filename)
	}

	return service.DetectionInput{
		Data:        data,
		Filename:    header.Filename,
		ContentType: contentType,
	}, nil
}

// validateInput validates the detection input.
func (h *Handler) validateInput(input service.DetectionInput) error {
	// Must have some content
	if input.URL == "" && input.Text == "" && len(input.Data) == 0 {
		return errors.New("no content provided")
	}

	// Validate URL if provided
	if input.URL != "" {
		if !strings.HasPrefix(input.URL, "http://") && !strings.HasPrefix(input.URL, "https://") {
			return errors.New("URL must start with http:// or https://")
		}
	}

	// Validate text length
	if input.Text != "" {
		if len(input.Text) < 10 {
			return errors.New("text too short: minimum 10 characters")
		}
		if len(input.Text) > 100000 {
			return errors.New("text too long: maximum 100,000 characters")
		}
	}

	// Validate file size
	if len(input.Data) > 0 {
		if int64(len(input.Data)) > h.maxUploadSize {
			return errors.New("file too large")
		}
	}

	return nil
}

// GetResult handles GET /verify/{id} requests.
// Returns the result of a previous verification by ID.
func (h *Handler) GetResult(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Extract ID from path
	id := r.PathValue("id")
	if id == "" {
		h.writeError(w, http.StatusBadRequest, "missing_id", "Job ID is required")
		return
	}

	// Look up job
	job, err := h.repository.GetJob(r.Context(), id)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			h.writeError(w, http.StatusNotFound, "not_found", "Verification result not found")
			return
		}
		h.logger.Error("failed to get job", "error", err, "id", id)
		h.writeError(w, http.StatusInternalServerError, "internal_error", "Failed to retrieve result")
		return
	}

	// Build response
	response := VerifyResponse{
		ID:          job.ID,
		Human:       job.Human,
		Confidence:  job.Confidence,
		ContentType: job.ContentType,
		CreatedAt:   job.CreatedAt,
	}

	h.writeJSON(w, http.StatusOK, response)
}

// Health handles GET /health requests.
// Returns service health status for monitoring and load balancers.
func (h *Handler) Health(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Check database connectivity
	dbHealthy := true
	if err := h.repository.Ping(r.Context()); err != nil {
		dbHealthy = false
		h.logger.Warn("database health check failed", "error", err)
	}

	status := "healthy"
	httpStatus := http.StatusOK

	if !dbHealthy {
		status = "degraded"
		// Still return 200 - the API can work with degraded storage
	}

	response := map[string]any{
		"status":    status,
		"timestamp": time.Now().UTC().Format(time.RFC3339),
		"checks": map[string]bool{
			"database": dbHealthy,
		},
	}

	h.writeJSON(w, httpStatus, response)
}

// Index handles GET / requests.
// Returns API information and links.
func (h *Handler) Index(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	response := map[string]any{
		"name":    "HumanMark API",
		"version": "1.0.0",
		"description": "Verify whether content was created by a human or generated by AI",
		"endpoints": map[string]string{
			"POST /verify":      "Verify content (accepts URL, text, or file upload)",
			"GET /verify/{id}":  "Get verification result by ID",
			"GET /health":       "Health check endpoint",
		},
		"documentation": "https://github.com/humanmark/humanmark",
	}

	h.writeJSON(w, http.StatusOK, response)
}

// writeJSON writes a JSON response.
func (h *Handler) writeJSON(w http.ResponseWriter, status int, data any) {
	w.WriteHeader(status)
	if err := json.NewEncoder(w).Encode(data); err != nil {
		h.logger.Error("failed to encode response", "error", err)
	}
}

// writeError writes an error response.
func (h *Handler) writeError(w http.ResponseWriter, status int, code string, message string) {
	h.writeJSON(w, status, ErrorResponse{
		Error: message,
		Code:  code,
	})
}
